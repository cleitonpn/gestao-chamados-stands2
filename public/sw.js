// public/sw.js

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Ciclo de vida bÃ¡sico
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
self.addEventListener('install', (event) => {
  // atualiza imediatamente quando hÃ¡ nova versÃ£o
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  // assume controle das pÃ¡ginas abertas
  event.waitUntil(clients.claim());
});

// Util: broadcast para todas as janelas do app
async function broadcast(msg) {
  const all = await clients.matchAll({ type: 'window', includeUncontrolled: true });
  for (const c of all) {
    try { c.postMessage(msg); } catch (_) {}
  }
}

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Push â†’ exibir notificaÃ§Ã£o + pedir badge Ã s pÃ¡ginas
// Payload esperado (JSON):
// { title, body, url, tag, badgeCount }
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
self.addEventListener('push', (event) => {
  event.waitUntil((async () => {
    let data = {};
    try {
      data = event.data ? event.data.json() : {};
    } catch (_) {}

    const {
      title = 'AtualizaÃ§Ã£o',
      body = 'VocÃª tem novidades.',
      url = '/',
      tag = 'updates',
      badgeCount
    } = data;

    const opts = {
      body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/icon-192x192.png',
      vibrate: [100, 50, 100],
      tag,
      renotify: false,
      requireInteraction: false,
      data: { url }
    };

    // Exibir a notificaÃ§Ã£o nativa do sistema
    await self.registration.showNotification(title, opts);

    // Pede para as pÃ¡ginas definirem/limparem a "bolinha" (quando suportado)
    if (typeof badgeCount !== 'undefined') {
      await broadcast({ type: 'BADGE_SET', count: Number(badgeCount) || 0 });
    }
  })());
});

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Clique na notificaÃ§Ã£o â†’ focar/abrir URL alvo
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const target = event.notification?.data?.url || '/';
  const full = new URL(target, self.location.origin).href;

  event.waitUntil((async () => {
    const all = await clients.matchAll({ type: 'window', includeUncontrolled: true });

    // se jÃ¡ existe uma aba/janela nesse path, foca e navega
    for (const c of all) {
      if (c.url === full) {
        await c.focus();
        try { c.navigate(full); } catch (_) {}
        return;
      }
    }
    // senÃ£o, abre uma nova
    await clients.openWindow(full);
  })());
});

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Fechou a notificaÃ§Ã£o (opcional)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
self.addEventListener('notificationclose', (_event) => {
  // Se quiser, envie telemetria/analytics aqui.
});

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// MudanÃ§a de assinatura (expiraÃ§Ã£o/rota de push)
// â†’ avisa as pÃ¡ginas para refazer a assinatura
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
self.addEventListener('pushsubscriptionchange', (event) => {
  event.waitUntil(broadcast({ type: 'PUSH_SUBSCRIPTION_CHANGED' }));
});

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Utilidade para testes: pÃ¡ginas podem pedir
// para o SW criar uma notificaÃ§Ã£o local
// window.navigator.serviceWorker.controller.postMessage({type:'TEST_NOTIFY', title, body, url})
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
self.addEventListener('message', (event) => {
  const msg = event.data || {};
  if (msg.type === 'TEST_NOTIFY') {
    const title = msg.title || 'ðŸ”” Teste';
    const body = msg.body || 'NotificaÃ§Ã£o criada pelo Service Worker.';
    const url = msg.url || '/';
    event.waitUntil(self.registration.showNotification(title, {
      body, icon: '/icons/icon-192x192.png', badge: '/icons/icon-192x192.png', data: { url }
    }));
  }
});
